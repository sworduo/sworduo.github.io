---
title: 现代操作系统第二章——进程
date: 2019-03-06 16:46:11
tags: 
- 操作系统
- 进程
categories: 操作系统
copyright: true
---

{% asset_img head.jpg %}
<!--more-->
#	2.1
进程：
##	2.1.1进程模型：进程就是一系列相关事情的抽象，e.g.一个厨师准备材料，生火煮水，按照菜谱做一顿饭整个过程就是一个进程
##	2.1.2进程的创建：一件事情自然包括开始和结束，进程也不例外，
相比于关心进程创建（因系统而异），我们更应该关心下进程什么时候会被创建。
进程创建的原因主要有以下几种：
*	1）系统初始化
*	2）执行了正在运行的进程所调用的进程创建系统调用
*	3）用户请求创建了一个新进程
*	4）一个批处理作业的初始化
两个进程间有不同的地址空间，当然某些稀有资源是共享的。
##	2.1.3进程的终止：
进程的终止同样有数种方式：
*	1）执行完任务正常退出
*	2）发生错误，返回错误代码，正常退出
*	3）被其他进程杀死，非正常退出
*	4）严重错误，非正常退出（比如说访问了不存的内存，执行了非法指令或除数为0等）
##	2.1.4进程的层次结构：
在unix中，父进程和其所有子女后裔组成一个进程组
在windows中，所有进程都是地位相同的，但是父进程有一个可以转移的、控制子进程的句柄。
##	2.1.5进程的状态：
由于cpu的资源是有限的，但是可能同时存在多个进程争夺cpu资源，
这样一来进程就产生了不同的状态：
*	1）就绪态，实际占用cpu
*	2）就绪态，可运行，但由于cpu已被占满，等待空闲cpu
*	3）阻塞态，除非某种外部事件发生，否则进程不能运行，一般来说情况有两种：其一是等待I/O输入拉取数据；其二是这个进程等待进入共享资源
状态间联系：
*	1）就绪->运行：根据调度程序切换
*	2）运行->就绪：当属于此进程的时间片用完后，若其还未结束，则让出cpu转为就绪状态等待调度程序
*	3）运行->阻塞：需要等待某些事情才能继续执行
*	4）阻塞->就绪：等待的事情完成了，切为就绪态
附加：阻塞->运行可以实现，只要这时候cpu空闲即可，但是就绪到->阻塞不会实现，因为进程进入就绪态代表他可以运行，而一个进程只有遇到需要等待的事情时，
才会进入阻塞态，但是就绪态的进程状态不会改变，也就是说他不会有需要等待的事情发生，所以不可能从就绪态直接切换到阻塞态。
##	2.1.6进程的实现：
那么，进程有哪些东西来表示的呢？或者说一个进程由哪些变量来唯一表示。
操作系统会维护一个进程表，里面有进程状态的重要信息，包括：
程序计数器、堆栈指针、内存分配情况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换成就绪态或阻塞态时所必须要保存的信息
详见52页。
##	2.1.7多道程序设计模型：
我们的目标是，尽可能的让cpu有活干，也就是说，尽可能的让cpu中执行的进程处于cpu计算的比例大于阻塞等待输入输出的比例。

#	2.2线程：
线程和进程神似，不同的是，各个线程共享其进程的地址空间和所有可用的数据。
##	2.2.1线程的使用：
使用线程的理由：
#	1）将一个进程分成多个线程，相当于一系列动作拆分成多个动作，当你煮水的时候可以同时煮菜。
#	2）线程的创建和撤销比进程快10~100倍，在有大量线程需要动态和快速修改时，具有这一特性很有用。
#	3）如果存在大量的计算和大量的I/O处理，拥有多个线程允许这些活动批次重叠进行，提高执行速率。
##	2.2.2经典的线程模型：
进程模型基于两种独立的概念：资源分组处理与执行。
资源管理的单位是进程而不是线程。
线程概念试图实现的是，共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一项任务而共同工作。
##	2.2.4在用户空间实现线程：
把整个线程包放在用户空间中，内核对线程包一无所知。
每个进程都有专用的线程表。
优点：
*	1）进行线程切换可以再几条指令内完成，比内核中实现要快一个数量级。
*	2）不需要陷阱，不需要上下文切换，不需要对内存高速缓存进行刷新，使得线程调度非常快捷。
*	3）允许每个进程有自己定制的调度算法。
缺点：
*	1）实现阻塞调用的方式效率不高也不优雅。
*	2）若一个线程引起页面故障时，内核会阻塞整个进程和所有线程，即便其他线程能用。
*	3）如果一个线程开始运行，那么在该进程中的其他线程就不嗯能够运行，除非第一个线程自动放弃cpu。
争论点：多线程的提出是为了应对经常发生线程阻塞的的情况，对于基本上是cpu密集型而且极少有阻塞的应用程序来说，多线程没啥意义。
##	2.2.5在内核中实现线程：
内核中有记录所有线程的线程表。
引发的问题：
*	1）如果一个进程创建了一个子进程，子进程应该继承哪些线程？
*	2）进程间通信时，信号该给哪个线程？
##	2.2.6混合实现：
使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。
##	2.2.7调度程序激活机制：
##	2.2.8弹出式线程：一个消息的到达导致系统创建一个处理该消息的线程。
##	2.2.9使单线程代码多线程化。

#	2.3进程间通信：
问题：
*	1）如何传递消息
*	2）确保两个或多个进程在关键活动中不会出现交叉
*	3）与正确的顺序有关，比如说打印进程得在产生数据的进程后面
##	2.3.1竞争条件：
两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确顺序，成为竞争条件。
##	2.3.2临界区：
互斥：以某种手段确保当一个进程使用一个共享变量或文件时，其他进程不能做同样的事情。
临界区：对共享内存进行访问的程序片段。
好的解决方案的条件：
*	1）任何两个进程不能同时处于其临界区。
*	2）不应对cpu的速度和数量进行假设。
*	3）临界区外运行的进程不得阻塞其他进程
*	4）不得使用进程无限等待进入临界区。
##	2.3.3忙等待的互斥：
当进入不到临界区时，一直发出邀请知道能进位置。
*	1）屏蔽中断：
一个进程进入临界区后关闭所有中断，离开时打开中断。
问题：
	*	a.如果进程进入了不离开怎么办。
	*	b.对于多处理器而言，一个处理器的中断仅针对它本身有效。
*	2）锁变量：
给临界区加锁。
问题：若进程a测试锁，能进，但是刚好其时间片到切换到进程b，进程再次检测，因为a还没来得及修改，所以b能进，并修改，而后轮到a，a又修改了一次。
此时有2个进程在访问临界区资源。
*	3）严格轮换法：
每个进程都有固定的访问临界区的时间，不管你实际是否在访问临界区，
这样的话，若是a想访问临界区资源，但是此时是b的访问时间，但是b实际并没有访问临界区的资源，
这样一来a就被一个临界区之外的进程阻塞了，违反了上述第三个条件。
*	4）peterson解法
在需要时使进程等待，知道能安全进入临界区。
*	5）TSL指令：
TSL （test and set lock）测试并加锁。
这个保证读字和写字时不可分割的，即该指令结束前其他处理器均不允许访问该内存。
##	2.3.4睡眠并唤醒：
peterson和tsl解法都是正确的，但是有忙等待的缺点。
若一个进程想访问某个临界区未果时进入休眠模式，并等待外部条件唤醒。
缺点：有可能永远沉睡。
##	2.3.5信号量：一个累计唤醒次数的整形变量。
将检查数值、修改变量值以及可能发生的睡眠操作作为一个单一的、不可分割的源自操作。可以通过将他们内置到一个系统调用中实现。
##	2.3.6互斥量：
互斥量是一个可以处于两态之一的变量：解锁和加锁。
##	2.3.8消息传递：
达到同步效果（之前有管城、互斥量信号量的结合）的另一种方法：
前一个调用向一个给定的目标发送一条消息，后一个调用从一个给定的源接受一条消息。
如果没有消息可用，则接受者可能被阻塞，知道一条消息到达，或者，带着一个错误码立即返回。
##	2.3.9屏障
在有些应用中划分了若干个阶段，只有所有进程都就绪着手下一个阶段时，才能进入下一个阶段，先完成的阶段到达屏障，等待其他进程。

#	2.4调度
调度需要决定哪个需要进行以及进行多少时间。
##	2.4.1调度极少
*	1）何时进行调度。
	*	a.在创建一个新进程后，可由调度程序合法选择先运行父进程还是子进程。
	*	b.在一个进程退出时选择一个就绪的进程。
	*	c.当一个进程阻塞时，选择另一个进程进行。
	*	d.在一个I/O中断发生时，必须做出调度决策，决定是否让新就绪的进程运行
*	2）调度算法：
	*	a.批处理：吞吐量 周转时间 cpu利用率前两个时衡量的重要因素，注意吞吐量大不代表周转时间快，考虑多个小作业和一个贼大作业，一般是把大作业放后面做。
	*	b.交互式系统：响应时间 均衡性,响应时间是首要因素
	*	c.实时系统：满足截止时间 （比如音频传输，如果超过一定时间就会卡顿）可预测性
##	2.4.2批处理系统：
*	1）先来先服务
*	2）最短作业优先
*	3）最短剩余作业优先
##	2.4.3交互式系统的调度
*	1）轮转调度
*	2）优先级调度
*	3）多级队列：优先级高时间片少，因为优先级高代表要响应快，而同一优先级里一般会有多个进程，这代表这多个进程反应都要快。优先级低代表要处理的数据大，所以时间片长（减少进程切换有利于提高效率），注意这里是指同一优先级中一个进程的时间片长，若是有优先级高的进程加入，则会无条件切换到优先级高的进程。也就是说，这其实是，在没有比他更高优先级的进程存在时，同级的进程切换尽可量少。
*	4）最短进程优先
*	5）保证调度
*	6）彩票调度
*	7）公平分享调度：上面的都只是考虑进程本身却没考虑到进程所属，比如说用户a9个进程，用户b1个进程，若是上面的调度算法，则用户2只占cpu的10%，而采用公平分享调度，可以确保用户b占用cpu的50%。假设用户a 有ABC当然不一定是每个用户平分整个cpu，具体划分方法可以商榷。
##	2.4.4实时系统中的额调度：
实时系统中有一条很重要的原则：正确的但是迟到的应答往往比没有还要糟糕（当然偶尔很少会有些容忍）
##	2.4.5策略和机制
将调度算法以某种形式参数化，而参数可以由用户进程调谐。
##	2.4.6线程调度
##	2.5经典的IPC问题
互斥量：保证一段时间只有一个用户访问临界区
信号量：睡眠或者活跃
状态量：判断是否睡眠或者活跃的依据

lastmodified 20170302 22:32


