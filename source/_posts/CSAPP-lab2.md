---
title: CSAPP-lab2-BOMB
date: 2019-05-15 23:41:40
tags:
- c语言
- CSAPP
categories: c语言
copyright: true
---
{% asset_img head.jpg %}
本次实验主要考察汇编代码以及GDB调试的应用。实验总共要求6次输入，每次输入都正确才算完成实验，每次输入的值隐藏在汇编代码中。实验通过反汇编二进制文件得到汇编代码，通过GDB查看寄存器值和内存器值辅助阅读代码，理解代码之间的逻辑及联系，找到解题的关键。
<!--more-->

#	预备知识

首先介绍一下要用到的命令：  

反汇编bomb文件，并将得到的汇编代码保存在code.txt中方便查看。（只需要汇编代码就行，符号表不需要）  



```

objdump -d bomb > code.txt

```



gdb命令：  

*	gdb bomb	用gdb对bomb进行调试

*	run		从头开始运行程序

*	kill	结束运行程序

*	break *0x80483c3	在地址0x80483c3处设置断点

*	delete	删除所有断点

*	stepi	运行一条指令

*	continue	继续执行直到遇到下一个断点

*	until 3	据徐执行直到遇到断点3（gdb会自动给每个断点编号）

*	print /x $rax	以16进制打印寄存器中rax的值

*	print /x ($rsp+8)	以16进制打印rsp的内容+8的值。注意这里是rsp寄存器的**内容**，而不是所对应的栈地址的值。简单来说，是得到$rsp+8的值，而不是($rsp+8)的值。

*	x/w 0xbffff890	检索以地址0xbffff890为首连续四个字节的数据。

*	x/s 0xbffff890  检索以地址0xbffff890为首的字符串。

*	x/w ($rsp+8)	检索以rsp+8为首地址的四个字节，简单来说，是获得(rsp+8)而不是rsp+8。



#	phase_1

第一个炸弹非常简单，方便我们熟悉汇编代码和gdb的操作。  

首先在code.txt中找到main函数的代码，因为程序总是从main开始开始的，然后找到第一个炸弹phase_1的程序入口，查看代码。  

分析phase_1中的代码，当执行嵌套函数<strings_not_equal>后，寄存器eax的值为0时可以解除第一个炸弹。所以我们查看*strings_not_equal*的代码，观察什么条件下才能使得eax=0。  



```

  0000000000401338 <strings_not_equal>:

  401338:	41 54                	push   %r12

  40133a:	55                   	push   %rbp

  40133b:	53                   	push   %rbx

  40133c:	48 89 fb             	mov    %rdi,%rbx   //rbx此時指向输入字符串的首字節地址

  40133f:	48 89 f5             	mov    %rsi,%rbp #rsi=正确字符串地址

  401342:	e8 d4 ff ff ff       	callq  40131b <string_length>

  401347:	41 89 c4             	mov    %eax,%r12d  //r12d保存输入字符串的长度

  40134a:	48 89 ef             	mov    %rbp,%rdi  //rbp指向正确字符串的地址

  40134d:	e8 c9 ff ff ff       	callq  40131b <string_length>

  401352:	ba 01 00 00 00       	mov    $0x1,%edx

  401357:	41 39 c4             	cmp    %eax,%r12d

  40135a:	75 3f                	jne    40139b <strings_not_equal+0x63>  //长度不相等后面就不用比较了

  40135c:	0f b6 03             	movzbl (%rbx),%eax  //如果(rbx)即输入字符串为空，则认为解除炸弹，若不为空，则需要和正确字符串比较。

  40135f:	84 c0                	test   %al,%al

  401361:	74 25                	je     401388 <strings_not_equal+0x50>

  401363:	3a 45 00             	cmp    0x0(%rbp),%al   //判断正确字符串当前字母，与输入字符串当前字母是否相等

  401366:	74 0a                	je     401372 <strings_not_equal+0x3a>

  401368:	eb 25                	jmp    40138f <strings_not_equal+0x57>

  40136a:	3a 45 00             	cmp    0x0(%rbp),%al

  40136d:	0f 1f 00             	nopl   (%rax)   //占位，空操作

  401370:	75 24                	jne    401396 <strings_not_equal+0x5e>

  401372:	48 83 c3 01          	add    $0x1,%rbx

  401376:	48 83 c5 01          	add    $0x1,%rbp

  40137a:	0f b6 03             	movzbl (%rbx),%eax

  40137d:	84 c0                	test   %al,%al

  40137f:	75 e9                	jne    40136a <strings_not_equal+0x32>

  401381:	ba 00 00 00 00       	mov    $0x0,%edx 

   #(rbx)和(rbp）逐个字母比较，如果(rbx)即输入字符串为空，意味着输入字符串检查完了。

   #又因为能进到这段程序意味着输入字符串与正确字符串长度相等，可以知道当出现空时，代表输入和正确字符串相等;若不为空，则继续比较。

   #所以接下来的事情很简单，断点，查看每一次rbp字符串对应的内存地址的字母即可。

  401386:	eb 13                	jmp    40139b <strings_not_equal+0x63>

  401388:	ba 00 00 00 00       	mov    $0x0,%edx

  40138d:	eb 0c                	jmp    40139b <strings_not_equal+0x63>

  40138f:	ba 01 00 00 00       	mov    $0x1,%edx

  401394:	eb 05                	jmp    40139b <strings_not_equal+0x63>

  401396:	ba 01 00 00 00       	mov    $0x1,%edx

  40139b:	89 d0                	mov    %edx,%eax  //返回eax=0表示输入的字符串正确

  40139d:	5b                   	pop    %rbx

  40139e:	5d                   	pop    %rbp

  40139f:	41 5c                	pop    %r12

  4013a1:	c3                   	retq   

```



仔细阅读代码，发现就是比较rsi和rdi寄存器的值，若相同则能使eax为0。运行程序，输入数据，发现rdi存放的就是我们输入的数据，那么rsi就是正确的数据。回到phase_1中，发现rsi的值是0x402400。ok，直接使用x/s 0x402400即可获得正确的字符串。    

 

#	phase_2

第二个实验比较直观，看汇编代码就可以。  



```

0000000000400efc <phase_2>:

  400efc:	55                   	push   %rbp

  400efd:	53                   	push   %rbx

  400efe:	48 83 ec 28          	sub    $0x28,%rsp

  400f02:	48 89 e6             	mov    %rsp,%rsi

  400f05:	e8 52 05 00 00       	callq  40145c <read_six_numbers>  //读6个数字

  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)    //rsp指向的就是读到的第一个数字，并且判断第一个数字是不是1

  400f0e:	74 20                	je     400f30 <phase_2+0x34>  //如果是1,那么继续，否则爆炸;也就是说，正确序列第一个数字是1

  400f10:	e8 25 05 00 00       	callq  40143a <explode_bomb>

  400f15:	eb 19                	jmp    400f30 <phase_2+0x34>

  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax

  400f1a:	01 c0                	add    %eax,%eax   //后一个正确的数字应该是前一个数字的两倍。显然正确序列就是1 2 4 8 16 32

  400f1c:	39 03                	cmp    %eax,(%rbx)  

  400f1e:	74 05                	je     400f25 <phase_2+0x29>

  400f20:	e8 15 05 00 00       	callq  40143a <explode_bomb>

  400f25:	48 83 c3 04          	add    $0x4,%rbx   //一个数字int是4个字节

  400f29:	48 39 eb             	cmp    %rbp,%rbx   //rbp用于结束循环

  400f2c:	75 e9                	jne    400f17 <phase_2+0x1b>

  400f2e:	eb 0c                	jmp    400f3c <phase_2+0x40>

  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx

  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp

  400f3a:	eb db                	jmp    400f17 <phase_2+0x1b>

  400f3c:	48 83 c4 28          	add    $0x28,%rsp

  400f40:	5b                   	pop    %rbx

  400f41:	5d                   	pop    %rbp

  400f42:	c3                   	retq   



```



#	phase_3

第三个炸弹比较巧妙。根据汇编代码以及gdb查看寄存器值，我们可以判断出eax存放的是输入的数据个数，当输入个数大于等于2时，eax=2，输入一个数时eax为1，而这里要求eax大于1，再结合上下代码，我们可以判断出一个只需要输入两个数字，第一个数字存放在rsp+8中，第二个存放于rsp+0xc中，即便你输入更多的数字，也只有前两个是有效的，其余忽略。  

仔细查看代码，可以发现最重要的一行跳转指令jmpq   *0x402470(,%rax,8)，程序将跳转到(0x402470+8*第一个数字）处，并赋值eax，然后eax和输入的第二个数字进行比较，若相等，则解除炸弹。查看地址0x402488，发现其内容是0x400f8a，恰好是跳转到后面的指令。  

这很好理解，0x402488是一张表table的起始点，第一个数字是索引下标index，第二个数字等于table[index]的值即可解除炸弹。  



```

0000000000400f43 <phase_3>:

  400f43:	48 83 ec 18          	sub    $0x18,%rsp

  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx

  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx

  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi

  400f56:	b8 00 00 00 00       	mov    $0x0,%eax      

  400f5b:	e8 90 fc ff ff       	callq  400bf0 <__isoc99_sscanf@plt>

  400f60:	83 f8 01             	cmp    $0x1,%eax                  #%eax保存输入个数，输入个数大于等于2则eax=2,输入1个数eax=1,这里只要求输入个数大于1个即可，

  									  #但实际有效输入只有前两个，其他忽略，比如3 256是正确，那么3 256 78 也是正确的。

  400f63:	7f 05                	jg     400f6a <phase_3+0x27>      #($rsp+8)=输入的第一个值，类似于数组A的下标n,($rsp+0xc)=输入的第二个值，与数组A[n]存放的值进行比较，

  400f65:	e8 d0 04 00 00       	callq  40143a <explode_bomb>      #x/w 0x402470+8*%rax可以查看跳转地址，相当于查看第n个数组值x

  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)             #第二个输入值等于x即可。

  400f6f:	77 3c                	ja     400fad <phase_3+0x6a>

  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax

  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)

  

  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax      

  400f81:	eb 3b                	jmp    400fbe <phase_3+0x7b>

  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax 	   #第一个输入为2，第二个输入为0x2c3

  400f88:	eb 34                	jmp    400fbe <phase_3+0x7b>

  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax     #第一个输入为3，第二个输入为0x100

  400f8f:	eb 2d                	jmp    400fbe <phase_3+0x7b>

  400f91:	b8 85 01 00 00       	mov    $0x185,%eax     #第一个输入为4，第二个输入为0x185

  400f96:	eb 26                	jmp    400fbe <phase_3+0x7b>

  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax      #第一个输入为5，第二个输入为0xce

  400f9d:	eb 1f                	jmp    400fbe <phase_3+0x7b>

  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax     #第一个输入为6，第二个输入为0x2aa

  400fa4:	eb 18                	jmp    400fbe <phase_3+0x7b>

  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax     #第一个输入为7，第二个输入为0x147

  400fab:	eb 11                	jmp    400fbe <phase_3+0x7b>

  400fad:	e8 88 04 00 00       	callq  40143a <explode_bomb>

  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax

  400fb7:	eb 05                	jmp    400fbe <phase_3+0x7b>

  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax

  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax

  400fc2:	74 05                	je     400fc9 <phase_3+0x86>

  400fc4:	e8 71 04 00 00       	callq  40143a <explode_bomb>

  400fc9:	48 83 c4 18          	add    $0x18,%rsp

  400fcd:	c3                   	retq   



```



#	phase_4

简单分析一下代码，发现eax代表的是读入的数字，当读入数字大于等于2时，eax=2，否则eax为1。而rsp+8存放的是第一个读入的数字，rsp+c存放的是第二个读入的数字，如果你输入多余2个数字，那么其余数字将会舍弃。  

仔细看一下代码，发现只有一处cmpl $0x0, 0xc(%rsp)用到了第二个输入数字，结合判定条件，显然第二个数字是0。  

再分析一下func4这个代码，当且仅当ecx等于第一个输入数字时，程序才会返回eax=0这个我们想要的结果。而第一次进入func4时，ecx的值是7，所以第一个输入的数字是7。  

Func4其他的代码构成了一个递归序列，属于烟雾弹坑人的，一开始我掉进去了很久才醒悟过来。根本没必要弄清楚函数递归时各个寄存器的关系，只需要弄明白什么条件下能获得想要的结果就行。    



```

000000000040100c <phase_4>:

  40100c:	48 83 ec 18          	sub    $0x18,%rsp

  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx

  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx

  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi

  40101f:	b8 00 00 00 00       	mov    $0x0,%eax

  401024:	e8 c7 fb ff ff       	callq  400bf0 <__isoc99_sscanf@plt>

  401029:	83 f8 02             	cmp    $0x2,%eax                  #%eax=输入个数，输入个数大于等于2,则%eax=2，比如输入2 3 4，%eax也等于2,输入3,%eax=1

  40102c:	75 07                	jne    401035 <phase_4+0x29>

  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)                #%rsp+8存储值小于等于0xe，%rsp+8保存第一个输入值，%rsp+0xc保存第二个。这题只有2个有效输入值。

  401033:	76 05                	jbe    40103a <phase_4+0x2e>

  401035:	e8 00 04 00 00       	callq  40143a <explode_bomb>

  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx

  40103f:	be 00 00 00 00       	mov    $0x0,%esi

  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi

  401048:	e8 81 ff ff ff       	callq  400fce <func4>

  40104d:	85 c0                	test   %eax,%eax   #%eax=0才能解除

  40104f:	75 07                	jne    401058 <phase_4+0x4c>

  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)   %rsp+0xc存储值=第二个输入数字=0

  401056:	74 05                	je     40105d <phase_4+0x51>

  401058:	e8 dd 03 00 00       	callq  40143a <explode_bomb>

  40105d:	48 83 c4 18          	add    $0x18,%rsp

  401061:	c3                   	retq   



```



#	phase_5

这里一开始看到字符串比较，我就以为是之前的套路，查找正确字符串地址，发现是flyers，输入flyers，结果却是boom！！！爆炸了。  

仔细查看代码，发现并不是直接拿输入的字符串和"flyers"比较，而是对输入字符串低4位做一定操作后得到的结果和flyers比较。  

那么是什么操作呢？注意到程序中截取输入字符串中每个字母的低四位进行操作，结合movzbl 0x4024b0(%rdx), %edx，看一看0x4024b0处，发现是一堆字母。  

并且最后进行字符串比较的，是flyers和从0x4024b0偏移得到的字符串。  

明白了，0x4024b0就是一个含有flyers的表格，输入字符串低四位就是flyers在表格中的索引位置。  

所以只要数一下flyers在表格里是第几位，就可以分别得到输入字符串的低四位。  

又因为输入是字符串，所以查一下ascii表就行。最后的结果是ionefg。（不唯一，用大写字母应该也是可以的，只要低四位符合要求就行）。  



```
0000000000401062 <phase_5>:

  401062:	53                   	push   %rbx

  401063:	48 83 ec 20          	sub    $0x20,%rsp

  401067:	48 89 fb             	mov    %rdi,%rbx    #rbx存放输入的字符串首地址

  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax

  401071:	00 00 

  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)

  401078:	31 c0                	xor    %eax,%eax

  40107a:	e8 9c 02 00 00       	callq  40131b <string_length>

  40107f:	83 f8 06             	cmp    $0x6,%eax        #输入字符串长度为6

  401082:	74 4e                	je     4010d2 <phase_5+0x70>

  401084:	e8 b1 03 00 00       	callq  40143a <explode_bomb>

  401089:	eb 47                	jmp    4010d2 <phase_5+0x70>

  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx   #读取一个字符串，取其低四位，在0x4024b0处查表。具体的查表内容是flyers，我们需要指向flyers六个字母的索引。

  40108f:	88 0c 24             	mov    %cl,(%rsp)           #所以输入的字符串，低四位就是flyers在表处的索引。

  401092:	48 8b 14 24          	mov    (%rsp),%rdx

  401096:	83 e2 0f             	and    $0xf,%edx

  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx   #print (char *) 0x4024b0看到一连串字母

  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)

  4010a4:	48 83 c0 01          	add    $0x1,%rax

  4010a8:	48 83 f8 06          	cmp    $0x6,%rax

  4010ac:	75 dd                	jne    40108b <phase_5+0x29>  

  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)

  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi    #此处的字符串是flyers

  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi

  4010bd:	e8 76 02 00 00       	callq  401338 <strings_not_equal>

  4010c2:	85 c0                	test   %eax,%eax

  4010c4:	74 13                	je     4010d9 <phase_5+0x77>

  4010c6:	e8 6f 03 00 00       	callq  40143a <explode_bomb>

  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

  4010d0:	eb 07                	jmp    4010d9 <phase_5+0x77>

  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax

  4010d7:	eb b2                	jmp    40108b <phase_5+0x29>

  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax

  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax

  4010e5:	00 00 

  4010e7:	74 05                	je     4010ee <phase_5+0x8c>

  4010e9:	e8 42 fa ff ff       	callq  400b30 <__stack_chk_fail@plt>

  4010ee:	48 83 c4 20          	add    $0x20,%rsp

  4010f2:	5b                   	pop    %rbx

  4010f3:	c3                   	retq   
```



#	phase_6

第六个炸弹是最难的，变量赋值运算繁多，地址映射关系复杂，理不断剪还乱，需要将程序划分为几个模块来理解。  



##	读数

第一个阶段是读取六个数字，然后进入两个循环，第一个循环检查读入的数字是否大于0，小于等于6，第二个循环将前面的数字与后面的每个数字进行比较，保证相互之间不相等。  

综上输入的六个数字必须是1~6并且互不相等，所以必然是1，2，3，4，5，6六个数字，输入顺序需要我们进一步确定。  



```
00000000004010f4 <phase_6>:

  4010f4:	41 56                	push   %r14

  4010f6:	41 55                	push   %r13

  4010f8:	41 54                	push   %r12

  4010fa:	55                   	push   %rbp

  4010fb:	53                   	push   %rbx

  4010fc:	48 83 ec 50          	sub    $0x50,%rsp

  401100:	49 89 e5             	mov    %rsp,%r13

  401103:	48 89 e6             	mov    %rsp,%rsi

  401106:	e8 51 03 00 00       	callq  40145c <read_six_numbers>

  40110b:	49 89 e6             	mov    %rsp,%r14

  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d  

 #===========================================================================================  

 #section1

 #目的：读取6个数，这六个数互不相同且都小于等于6。

 #大循环执行六次，保证每个数字小于6,小循环执行6-i次，保证两两不相同。

 #读入数字放在rsp~(rsp+20)里

 #===========================================================================================   

  401114:	4c 89 ed             	mov    %r13,%rbp            #r13 #rbp指向当前需要判断的数字

  401117:	41 8b 45 00          	mov    0x0(%r13),%eax       #eax=r13所指向的数字

  40111b:	83 e8 01             	sub    $0x1,%eax            #eax<=6，即数字必须小于等于6

  40111e:	83 f8 05             	cmp    $0x5,%eax   

  

  #无符号比较，所以如果输入数字为0,则0-1溢出变成无穷大，又因为输入数字小于等于6,所以输入数字必定是1 2 3 4 5 6,只是顺序不确定

  401121:	76 05                	jbe    401128 <phase_6+0x34>   

  401123:	e8 12 03 00 00       	callq  40143a <explode_bomb>

  401128:	41 83 c4 01          	add    $0x1,%r12d  #r12d 控制下面程序的执行次数

  40112c:	41 83 fc 06          	cmp    $0x6,%r12d

  401130:	74 21                	je     401153 <phase_6+0x5f>   #执行6-r12d次

  401132:	44 89 e3             	mov    %r12d,%ebx    #ebx是控制小循环的计数器

  401135:	48 63 c3             	movslq %ebx,%rax

  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax

  40113b:	39 45 00             	cmp    %eax,0x0(%rbp)     #rbp外面大循环的数字，eax里面小循环的数字，两者必须不同

  40113e:	75 05                	jne    401145 <phase_6+0x51>

  401140:	e8 f5 02 00 00       	callq  40143a <explode_bomb>

  401145:	83 c3 01             	add    $0x1,%ebx    

  401148:	83 fb 05             	cmp    $0x5,%ebx    

  40114b:	7e e8                	jle    401135 <phase_6+0x41>   #循环判别条件

  40114d:	49 83 c5 04          	add    $0x4,%r13   #r13+4,相当于指向下一个数字

  401151:	eb c1                	jmp    401114 <phase_6+0x20>  

 
```


##	变数

用7减去输入的数字，并按照原来的顺序保存差的结果，进入下一个阶段。

```
section2

#对读入的每一个数字num有,num=7-num

#===========================================================================================   

  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi   #rsi=rsp+24=0

  401158:	4c 89 f0             	mov    %r14,%rax    #r14一开始指向rsp = 读入的第一个数字

  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx

  401160:	89 ca                	mov    %ecx,%edx

  401162:	2b 10                	sub    (%rax),%edx   #edx=7, (%rax)=第一个数字

  401164:	89 10                	mov    %edx,(%rax)    #第一个数字n变成 7-n

  401166:	48 83 c0 04          	add    $0x4,%rax   #rax指向下一个数字

  40116a:	48 39 f0             	cmp    %rsi,%rax   #rsi=rsp+24

  40116d:	75 f1                	jne    401160 <phase_6+0x6c>

  40116f:	be 00 00 00 00       	mov    $0x0,%esi

  401174:	eb 21                	jmp    401197 <phase_6+0xa3>

#===========================================================================================   
```





##	获取地址

每一个数字都对应一个地址，这个阶段是将数字对应的地址，按照数字输入的顺序存放到rsp+32中。  



```
  #===========================================================================================  

  #section3

  #ecx依次遍历6个数字，然后将每个数字对应的地址存放在rsp+32中

  #===========================================================================================

  #获取数字所对应的地址

  #数字对应的地址是固定的，但是地址存放的顺序是不确定的，由输入数字的顺序确定地址存放的顺序。

  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx

  40117a:	83 c0 01             	add    $0x1,%eax

  40117d:	39 c8                	cmp    %ecx,%eax  #ecx指向输入的数字,一开始eax=2

  40117f:	75 f5                	jne    401176 <phase_6+0x82> #若eax不等于ecx，则一直增大eax直到相等为止，同时改变rdx的值

  

  401181:	eb 05                	jmp    401188 <phase_6+0x94>

  

  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx  #获取数字1对应的地址

  #存放地址

  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)

  40118d:	48 83 c6 04          	add    $0x4,%rsi   #将rdx依次放入rsp+32中，一个地址8个字节。

  401191:	48 83 fe 18          	cmp    $0x18,%rsi  #一共放6次

  401195:	74 14                	je     4011ab <phase_6+0xb7>

  

  #->section2直接跳转到这里

  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx  #rsp还是指向第一个数字，一开始rsi=0，ecx依次遍历六个数字

  40119a:	83 f9 01             	cmp    $0x1,%ecx

  40119d:	7e e4                	jle    401183 <phase_6+0x8f>  #因为数字都小于等于6且互不相同，所以7-输入数字后，应该只有一个数字是小于等于1的。因为后面要求数字大于等于2,所以先把等于1的数字安排了。

  

  40119f:	b8 01 00 00 00       	mov    $0x1,%eax

  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx

  4011a9:	eb cb                	jmp    401176 <phase_6+0x82>

#=========================================================================================== 
```



##	变址

上一阶段存放到rsp+32中的地址只是内存地址，类似于指针，其本身还指向一个数值。  

这里要求将后一个地址存放到前一个地址的后面。  

  

```  
  #=========================================================================================== 

  #section4

  #将后一个地址放在前一个地址+8处，方便后面比较

  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx  #rbx=(rsp+32)=section3 第一个存入的地址

  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax  #rax指向第二个存入的地址

  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi  #rsi用于判断遍历结束

  

  4011ba:	48 89 d9             	mov    %rbx,%rcx  #rcx遍历存入rsp中的地址

  

  4011bd:	48 8b 10             	mov    (%rax),%rdx  #rdx是第二个存入的地址

  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)

  4011c4:	48 83 c0 08          	add    $0x8,%rax

  4011c8:	48 39 f0             	cmp    %rsi,%rax

  4011cb:	74 05                	je     4011d2 <phase_6+0xde>

  4011cd:	48 89 d1             	mov    %rdx,%rcx

  4011d0:	eb eb                	jmp    4011bd <phase_6+0xc9>

  #=========================================================================================== 
```



##	验证

这里要求前一个地址对应的值要大于后一个地址对应的值。  所以现在的任务就是找到输入数字、地址、地址值之间的关系。如下表所示：  



|原始输入数字|7-数字|地址|地址对应值|
|---|---|---|---|
|1|6|0x603320|0x1bb|
|2|5|0x603310|0x1dd|
|3|4|0x603300|0x2b3|
|4|3|0x6032f0|0x39c|
|5|2|0x60032e0|0xa8|
|6|1|0x60032d0|14c|



从表格以及要求我们可以知道，第一个输入数字对应的地址对应的值最大，最后一个输入数字对应的地址对应的值最小。  

不难得到正确的输入序列：4，3，2，1，6，5



``` 
  #=========================================================================================== 

  #section5

  #要求前一个地址对应的值要大于后一个地址对应的值。

  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)

  4011d9:	00 

  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp  #以下程序执行5次，目的(rbx)>=(rbx+8)，且(rbx+8)>=(rbx+16)如此类推

  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax  #rax是第二个地址

  4011e3:	8b 00                	mov    (%rax),%eax     #eax是第二个地址对应的内存中存放的数值

  4011e5:	39 03                	cmp    %eax,(%rbx)     #rbx是第一个地址，(rbx)是第一个地址对应的内存中存放的数值

  4011e7:	7d 05                	jge    4011ee <phase_6+0xfa>

  4011e9:	e8 4c 02 00 00       	callq  40143a <explode_bomb>

  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx

  4011f2:	83 ed 01             	sub    $0x1,%ebp   

  4011f5:	75 e8                	jne    4011df <phase_6+0xeb>

  4011f7:	48 83 c4 50          	add    $0x50,%rsp

  #=========================================================================================== 

  

  4011fb:	5b                   	pop    %rbx

  4011fc:	5d                   	pop    %rbp

  4011fd:	41 5c                	pop    %r12

  4011ff:	41 5d                	pop    %r13

  401201:	41 5e                	pop    %r14

  401203:	c3                   	retq   
```



#	总结

通过这次试验，大致了解了gdb的使用，虽然我觉得以后不太可能从事汇编相关的工作（看的脑疼），不过还是收获蛮多的。  