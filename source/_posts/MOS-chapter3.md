---
title: 现代操作系统第三章——存储管理
date: 2019-03-06 16:46:11
tags: 
- 操作系统
categories: 操作系统
copyright: true
---

{% asset_img head.jpg %}
<!--more-->

# 存储管理：
操作系统中管理分层存储器体系的部分称为存储管理器。它的任务是有效地管理内存，即记录哪些内存是正在使用的，哪些内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存。
# 3.1无存储管理器抽象：
早期存储器没有抽象，这意味着同一时间内内存中只能运行一个进程， 若运行第二个进程则会把原来的进程覆盖掉。
# 3.2 一种存储器抽象：地址空间
## 3.2.1地址空间的概念：
地址空间是一个进程可用于寻址的一套地址集合。每个进程都有一个独立于其他进程的地址空间。
### 问题：
独立的地址空间要解决的一个问题是，一个程序的地址中的28所对应的物理地址要和另一个程序中的地址28所对应的地址空间不同。在内存足够大的情况下，可采用下述方式解决这个问题：
-    基址寄存器与界限寄存器：使用一种简单的动态重定位的方法，当一个程序运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。每当进程访问内存时，CPU硬件会在把地址发送到内存总线前，自动把基址值加到进程发出的地址值上，同时，它检查提供的地址是否大于等于界限寄存器里的值，若是，会产生错误并中止访问。
## 3.2.2交换技术：
若内存不够大怎么办呢？事实上所有进程所需的RAM数量总和通常远远超出存储器能够支持的范围。而处理内存超载的方法一般有以下两种：
-    1)交换技术：把一个进程完整调入内存，使该内存运行一段时间，然后把它存回磁盘。
-    2)虚拟内存。
这里着重介绍交换技术，交换技术的在于，若事先不知道程序的大小，或者程序在运行的过程中大小会随之改变，那么就会产生诸如空洞或内存不够的问题。一个方法是程序装入时便预先分配更大的内存。但是如果预设的内存不够大的话，该程序会调出内存，直到内存有足够大的空间时才会放回。而由于每个进程大小不一样，所以调出内存存到磁盘的空间也不一样，这也使得在经过很多次交换之后，会出现一个又一个的空洞。
# 3.3虚拟内存：
一般来说一个程序在运行时不会用到所有的代码，甚至同一时间一个程序只会运行一小部分的代码，这也使得如果每次都把一个程序的所有代码都装进内存显然会很浪费。这也使得人们创造了另一种技术，虚拟内存。虚拟内存的基本思想是：每个程序拥有自己的地址空间，这个空间被分割成多个块，每个块称作一页或者页面。每一页有连续的地址范围，这些页被映射到物理内存，只有装载程序当前所需要的代码的页面会放入内存中，若是程序需要的页面不在内存中，就会产生一个页面故障，从磁盘中调出所需的页面并覆盖掉内存中的一个页面。那么究竟覆盖掉哪个页面呢？这就是页面调度算法索要解决的问题。
##　3.3.1分页：
虚拟地址空间按照固定大小划分成成为页面的若干单元，在物理内存中对应的页面称为页框。而虚拟地址到物理地址的映射是通过MMU（内存管理单元）实现的。假设一个虚拟地址有16位，那么一般高四位是页表号，低12位是偏移量。当进程需要访问某个字节时，它会把该字节所属的页面号发送给MMU。MMU中记载着虚拟地址的页表号和物理地址的页框号所对应的映射，当MMU收到页表号时，会找到其对应的物理地址的页框号，然后将页框号拼接到偏移地址的高位形成送往内存的物理地址。
##　3.3.2加速分页过程：
事实上计算机中存在这样的现象：大多数程序总是对少量的页面进行多次的访问。基于这样的现象，计算机设置一个称为TLB（转换检测缓冲区）的小型硬件设备，将虚拟地址直接映射到物理地址而不需要在MMU中查询页表项。
##　3.3.5针对大内存的页表：
### 1、多级页表：
一个页表中套着多个二级页表，若不够，则每个二级页表中套多个三级页表，以此类推。
### 2、倒排页表：
不再是一个页表对应一个页框，而是一个页框对应一个（进程，虚拟页面）项，为了解决查找速度慢的问题，我们可以采用TLB和散列表的方法减少查询量。
# 3.4页面置换算法：
-    最优页面置换算法：将每个页面都可以用在该页面首次被访问前所要执行的指令数作为标记，每次置换时置换标记最大的页面。然而这样几乎不能实现。
-    最近未使用页面置换算法：随机地从类编号最小的非空类中挑选一个页面淘汰之。
-    先进先出页面置换算法：由操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最久进入的页面放在表头。当发生页面中断时，淘汰表头的页面并把新调入的页面加到表尾。
-    第二次机会页面置换算法：寻找一个最近时钟间隔一来没有被访问过的页面。给每个页面维护一个标记R，若最老的页面R=1，将其R置0并放到末尾，就好像是新加入的页面一样。
-    时钟页面置换算法：第二次页面置换算法是移动每一个页表，而这里仅仅移动一个指针，消耗会少很多。
-    最近最少使用页面置换算法：老化算法。
-    工作集页面置换算法：上述所有算法都是请求调页，也就是只有当需要的时候才会被调入。设想一下当一个进程启动时，它会不停产生缺页中断直到其所有的工作集页面都装入内存中，显然太慢了。这里解释一下，一个进程正在使用的页面的结合称为它的工作集。一般而言，一个进程会将其最近k次访问的页面作为其工作集页面，又或者，将最近π秒实际运行实践中它所访问过的页面的集合。当发生页面中断时，首先调出没访问过的，且最近使用时间大于π秒的页面；其次是没访问过的，最近使用时间小于π秒的生存时间最长的页面；最后若所有页面都在π秒内访问过，则优先选取没被修改过的页面。
-    工作集时钟页面置换算法
# 3.5分页系统中的设计问题
## 3.5.1局部分配策略与全局分配策略
## 3.5.2负载控制
## 3.5.3页面大小
## 3.5.4分离的指令空间和数据空间
## 3.5.5共享页面
## 3.5.6共享库
## 3.5.7内存映射文件
## 3.5.8清除策略
## 3.5.9虚拟内存接口